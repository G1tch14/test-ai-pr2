{
  "7b2b0cfc-510f-4fa2-b466-53799fece31a" : {
    "id" : "7b2b0cfc-510f-4fa2-b466-53799fece31a",
    "projectId" : "40e94b0e-f7a6-46d6-9dfb-b0c13d8fde11",
    "rawInput" : "# \uD83D\uDE80 RTF Platform - Kafka Architecture\n\n## \uD83D\uDCCB Оглавление\n\n1. [Обзор архитектуры](#обзор-архитектуры)\n2. [Компоненты системы](#компоненты-системы)\n3. [Структура Kafka Topics](#структура-kafka-topics)\n4. [Потоки данных](#потоки-данных)\n5. [Версионирование и защита от race conditions](#версионирование)\n6. [Структура БД](#структура-бд)\n7. [Конфигурация](#конфигурация)\n\n---\n\n## \uD83C\uDFAF Обзор архитектуры\n\nАрхитектура построена на принципах **event-driven** взаимодействия через **Apache Kafka**, заменяя сложный LoadBalancer простой и эффективной системой обмена сообщениями.\n\n### Ключевые принципы:\n\n- ✅ **Kafka вместо LoadBalancer** - минимальные сообщения (только ID + команда)\n- ✅ **Версионирование (@Version)** - защита от грязных записей\n- ✅ **БД как единственный источник правды** - конфигурации хранятся в БД\n- ✅ **Боты пишут напрямую в БД** - ордера и статистика без промежуточных слоев\n- ✅ **Готовность к масштабированию** - легко добавлять новые серверы\n- ✅ **Идентификация через ENV** - каждый сервер имеет уникальный `BOT_SERVER_ID` в переменных окружения\n\n### \uD83D\uDD11 Идентификация серверов:\n\nКаждый bot-сервер имеет **уникальный ID в ENV переменной** `BOT_SERVER_ID`:\n\n1. **При деплое** - вручную прописывается UUID в `.env` файл или docker-compose\n2. **RTF** назначает бота конкретному серверу (записывает `server_id` в `bot_instances.ec2_id`)\n3. **Kafka сообщения** содержат `serverId` - бот-сервер проверяет \"это мне?\" и обрабатывает только свои команды\n4. **При восстановлении** - сервер загружает из БД всех ботов, где `ec2_id = MY_SERVER_ID`\n\n**Пример:**\n```bash\n# Server 1: .env\nBOT_SERVER_ID=550e8400-e29b-41d4-a716-446655440001\n\n# Server 2: .env\nBOT_SERVER_ID=550e8400-e29b-41d4-a716-446655440002\n```\n\n---\n\n## \uD83C\uDFD7️ Компоненты системы\n\n```mermaid\ngraph TB\n    subgraph Frontend\n        F[React Frontend<br/>Port 3000]\n    end\n    \n    subgraph RTF[RTF Backend - Spring Boot 8091]\n        API[REST API]\n        BM[Bot Management]\n        KP[Kafka Producer]\n        KC[Kafka Consumer]\n        MON[Server Monitor]\n    end\n    \n    subgraph Kafka[Apache Kafka - Port 9092]\n        T1[bot-commands]\n        T2[server-heartbeat]\n    end\n    \n    subgraph BotServers[Bot Servers - EC2 Python]\n        BS1[Bot Server 1<br/>Port 6969]\n        BS2[Bot Server 2<br/>Port 6969]\n        BS3[Bot Server N<br/>Port 6969]\n    end\n    \n    subgraph Database[Aurora DSQL]\n        DB[(PostgreSQL)]\n    end\n    \n    F -->|HTTP/REST| API\n    API --> BM\n    BM -->|Publish Events| KP\n    KP -->|bot.started<br/>bot.stopped<br/>bot.updated<br/>bot.closeAllPositions| T1\n    \n    BS1 -->|Heartbeat| T2\n    BS2 -->|Heartbeat| T2\n    BS3 -->|Heartbeat| T2\n    \n    T2 -->|Consume| KC\n    KC --> MON\n    \n    T1 -->|Consume| BS1\n    T1 -->|Consume| BS2\n    T1 -->|Consume| BS3\n    \n    BM -.->|READ/WRITE<br/>bot, config| DB\n    MON -.->|Cache<br/>heartbeat| DB\n    BS1 -.->|READ config<br/>WRITE orders/stats| DB\n    BS2 -.->|READ config<br/>WRITE orders/stats| DB\n    BS3 -.->|READ config<br/>WRITE orders/stats| DB\n    \n    style RTF fill:#e1f5ff\n    style Kafka fill:#fff3e0\n    style BotServers fill:#f3e5f5\n    style Database fill:#e8f5e9\n```\n\n---\n\n## \uD83D\uDCE8 Структура Kafka Topics\n\n### Topic 1: `bot-commands` (RTF → Bot-servers)\n\nКоманды для управления ботами. **Минимальные сообщения - только ID!**\n\n**Отправляются через Kafka (4 события):**\n- ✅ `bot.started` - запустить бота\n- ✅ `bot.stopped` - остановить бота\n- ✅ `bot.updated` - обновить конфигурацию\n- ✅ `bot.closeAllPositions` - закрыть позиции\n\n**НЕ отправляются через Kafka:**\n- ❌ `bot.created` - только сохранение в БД\n- ❌ `bot.deleted` - только удаление из БД\n\n**Формат событий:**\n\n```json\n{\n  \"eventType\": \"bot.started | bot.stopped | bot.updated | bot.closeAllPositions\",\n  \"botId\": \"bot-456\",\n  \"serverId\": \"550e8400-e29b-41d4-a716-446655440001\"\n}\n```\n\n**Размер:** ~100 bytes (минимум данных!)\n\n---\n\n### Topic 2: `server-heartbeat` (Bot-servers → RTF)\n\nМониторинг состояния серверов каждые 30 секунд.\n\n```mermaid\ngraph LR\n    subgraph Bot Servers\n        BS1[Server 1]\n        BS2[Server 2]\n        BS3[Server N]\n    end\n    \n    subgraph Kafka\n        HB[server-heartbeat topic]\n    end\n    \n    subgraph RTF\n        MON[Monitor Service]\n        DB[(Database)]\n    end\n    \n    BS1 -->|Every 30s| HB\n    BS2 -->|Every 30s| HB\n    BS3 -->|Every 30s| HB\n    \n    HB --> MON\n    MON -->|Save to CACHE| MON\n    MON -->|Check dead servers| DB\n    MON -.->|Reassign bots| HB\n```\n\n**Формат:**\n\n```json\n{\n  \"eventType\": \"server.heartbeat\",\n  \"ec2Id\": \"550e8400-e29b-41d4-a716-446655440001\",\n  \"botId\": \"bot-456\"\n}\n```\n\n---\n\n## \uD83D\uDD04 Потоки данных\n\n### Flow 1: Создание бота (БЕЗ Kafka!)\n\n```mermaid\nsequenceDiagram\n    participant Frontend\n    participant RTF\n    participant DB\n    \n    Frontend->>RTF: POST /api/bot/create\n    \n    Note over RTF: Select least loaded server\n    RTF->>DB: SELECT FROM bot_servers<br/>WHERE status='ACTIVE'<br/>ORDER BY load\n    DB-->>RTF: serverId: \"550e8400-...\"\n    \n    Note over RTF: Transaction BEGIN\n    RTF->>DB: INSERT INTO bot\n    RTF->>DB: INSERT INTO grid_bot_config\n    RTF->>DB: INSERT INTO bot_assignments<br/>(bot_id, server_id, status='INACTIVE')\n    RTF->>DB: INSERT INTO grid_bot_statistic\n    Note over RTF: COMMIT\n    \n    RTF-->>Frontend: 200 OK {botId}\n    \n    Note over RTF,DB: ❌ Kafka НЕ используется!<br/>Бот только сохранен в БД<br/>status = INACTIVE\n```\n\n---\n\n### Flow 2: Запуск бота (через Kafka!)\n\n```mermaid\nsequenceDiagram\n    participant Frontend\n    participant RTF\n    participant DB\n    participant Kafka\n    participant BotServer\n    \n    Frontend->>RTF: POST /api/bot/start\n    \n    RTF->>DB: SELECT server_id FROM bot_assignments<br/>WHERE bot_id=?\n    DB-->>RTF: serverId\n    \n    RTF->>DB: UPDATE bot<br/>SET bot_status='ACTIVE'\n    \n    RTF->>Kafka: Publish bot.started<br/>{botId, serverId}\n    RTF-->>Frontend: 200 OK\n    \n    Kafka->>BotServer: Deliver bot.started\n    \n    alt serverId == MY_SERVER_ID\n        alt Bot in memory\n            BotServer->>BotServer: Activate bot\n            BotServer->>BotServer: Start trading\n        else Bot NOT in memory\n            BotServer->>DB: SELECT bot, config, api_key\n            DB-->>BotServer: Full configuration\n            BotServer->>BotServer: Initialize bot\n            BotServer->>BotServer: Start trading\n        end\n        BotServer->>DB: UPDATE bot_assignments<br/>status='ACTIVE'\n    else serverId != MY_SERVER_ID\n        BotServer->>BotServer: Ignore (not my bot)\n    end\n```\n\n---\n\n### Flow 3: Обновление конфигурации\n\n```mermaid\nsequenceDiagram\n    participant Frontend\n    participant RTF\n    participant DB\n    participant Kafka\n    participant BotServer\n    \n    Frontend->>RTF: POST /api/bot/update\n    \n    RTF->>DB: SELECT server_id FROM bot_assignments<br/>WHERE bot_id=?\n    DB-->>RTF: serverId\n    \n    Note over RTF: Transaction with versioning\n    RTF->>DB: UPDATE bot<br/>WHERE id=? AND version=?\n    RTF->>DB: UPDATE grid_bot_config<br/>WHERE id=?\n    Note over RTF: COMMIT (version++)\n    \n    RTF->>Kafka: Publish bot.updated<br/>{botId, serverId}\n    RTF-->>Frontend: 200 OK\n    \n    Kafka->>BotServer: Deliver bot.updated\n    \n    alt serverId == MY_SERVER_ID\n        BotServer->>DB: SELECT grid_bot_config<br/>WHERE id=?\n        DB-->>BotServer: New configuration\n        BotServer->>BotServer: Apply new config<br/>to running bot\n    else serverId != MY_SERVER_ID\n        BotServer->>BotServer: Ignore (not my bot)\n    end\n```\n\n---\n\n### Flow 3: Торговля и запись ордеров\n\n```mermaid\nsequenceDiagram\n    participant Exchange\n    participant BotServer\n    participant DB\n    participant RTF\n    participant Frontend\n    \n    Note over BotServer: Bot is trading\n    \n    BotServer->>Exchange: Place order\n    Exchange-->>BotServer: Order filled\n    \n    BotServer->>DB: INSERT INTO grid_bot_order<br/>(id, bot_id, price, quantity, ...)\n    \n    BotServer->>DB: UPDATE grid_bot_statistic<br/>SET total_profit=?, ...<br/>WHERE bot_id=? AND version=?\n    \n    alt Version conflict\n        DB-->>BotServer: 0 rows updated\n        Note over BotServer: Retry with new version\n        BotServer->>DB: SELECT version\n        BotServer->>DB: UPDATE with correct version\n    else Success\n        DB-->>BotServer: 1 row updated\n    end\n    \n    Frontend->>RTF: GET /api/bot/{id}/statistics\n    RTF->>DB: SELECT FROM grid_bot_statistic\n    DB-->>RTF: Current statistics\n    RTF-->>Frontend: Statistics data\n```\n\n---\n\n### Flow 4: Мониторинг и переназначение при сбое\n\n```mermaid\nsequenceDiagram\n    participant BotServer\n    participant Kafka\n    participant RTF\n    participant DB\n    \n    loop Every 30 seconds\n        BotServer->>Kafka: Publish heartbeat<br/>{serverId, activeBots, maxBots}\n        Kafka->>RTF: Deliver heartbeat\n        RTF->>RTF: Save to CACHE<br/>(NOT to Database!)\n    end\n    \n    Note over RTF: Heartbeat в КЕШе!<br/>Экономия операций БД\n    \n    Note over RTF: Scheduled check every 60s<br/>(проверка КЕША!)\n    RTF->>RTF: Check CACHE<br/>timestamp < NOW() - 2 minutes\n    Note over RTF: Dead servers list from CACHE\n    \n    alt Dead server found\n        RTF->>DB: SELECT bots FROM bot_assignments<br/>WHERE server_id = dead_server_id\n        DB-->>RTF: Orphaned bots list\n        \n        loop For each orphaned bot\n            RTF->>DB: SELECT least loaded server\n            RTF->>DB: UPDATE bot_assignments<br/>SET server_id=new_server<br/>WHERE bot_id=? AND version=?\n            RTF->>Kafka: Publish bot.started<br/>{botId, newServerId}\n        end\n        \n        RTF->>DB: UPDATE bot_servers<br/>SET status='UNHEALTHY'<br/>WHERE server_id = dead_server_id\n    end\n```\n\n---\n\n## \uD83D\uDD12 Версионирование и защита от race conditions\n\nИспользуем **Optimistic Locking** через `@Version` (JPA) для предотвращения грязных записей.\n\n### Таблицы с версионированием:\n\n```mermaid\nerDiagram\n    BOT_ASSIGNMENTS {\n        bigint id PK\n        varchar bot_id UK\n        varchar server_id FK\n        varchar status \"ACTIVE | INACTIVE\"\n        bigint version \"Optimistic Lock\"\n    }\n    \n    BOT_SERVERS {\n        varchar server_id PK \"UUID from ENV\"\n        varchar status \"ACTIVE | INACTIVE | UNHEALTHY\"\n        integer max_bots\n        bigint version \"Optimistic Lock\"\n    }\n    \n    GRID_BOT_STATISTIC {\n        varchar id PK\n        decimal total_profit\n        decimal today_profit\n        integer current_order_count\n        bigint version \"Optimistic Lock\"\n    }\n    \n    BOT_ASSIGNMENTS }o--|| BOT_SERVERS : \"assigned to\"\n    BOT_ASSIGNMENTS ||--|| GRID_BOT_STATISTIC : \"has statistics\"\n```\n\n### Как работает версионирование:\n\n```mermaid\nsequenceDiagram\n    participant Process1\n    participant Process2\n    participant DB\n    \n    Note over Process1,Process2: Parallel updates to same record\n    \n    Process1->>DB: SELECT * WHERE id=1\n    Note over DB: version = 5\n    DB-->>Process1: Record (version=5)\n    \n    Process2->>DB: SELECT * WHERE id=1\n    Note over DB: version = 5\n    DB-->>Process2: Record (version=5)\n    \n    Process1->>DB: UPDATE ... <br/>WHERE id=1 AND version=5\n    Note over DB: version = 6\n    DB-->>Process1: ✅ Success (1 row)\n    \n    Process2->>DB: UPDATE ... <br/>WHERE id=1 AND version=5\n    Note over DB: version already 6!\n    DB-->>Process2: ❌ OptimisticLockException<br/>(0 rows)\n    \n    Process2->>Process2: Retry operation\n    Process2->>DB: SELECT * WHERE id=1\n    DB-->>Process2: Record (version=6)\n    Process2->>DB: UPDATE ... <br/>WHERE id=1 AND version=6\n    DB-->>Process2: ✅ Success\n```\n\n### Где используется:\n\n| Операция | Таблица | Кто обновляет | Защита от |\n|----------|---------|---------------|-----------|\n| Назначение бота на сервер | `bot_assignments` | RTF | Двойное назначение |\n| Обновление статистики | `grid_bot_statistic` | Bot-server | Параллельные обновления |\n| Обновление статуса сервера | `bot_servers` | RTF (heartbeat) | Конфликты при мониторинге |\n| Переназначение бота | `bot_assignments` | RTF (monitor) | Двойное переназначение |\n\n---\n\n## \uD83D\uDDC4️ Структура БД\n\n### Entity Relationship Diagram\n\n```mermaid\nerDiagram\n    USER_INFO ||--o{ BOT : owns\n    USER_INFO ||--o{ USER_API_KEY : has\n    \n    BOT ||--|| BOT_ASSIGNMENTS : assignment\n    BOT }o--|| USER_API_KEY : uses\n    BOT_ASSIGNMENTS }o--|| BOT_SERVERS : \"runs on\"\n    \n    %% Grid Bot - 4 entities\n    BOT ||--o| GRID_BOT_CONFIG : \"has config\"\n    BOT ||--o| GRID_BOT_HISTORICAL_DATA : \"has history\"\n    BOT ||--o{ GRID_BOT_ORDERS : \"has orders\"\n    BOT ||--o| GRID_BOT_STATISTIC : \"has statistics\"\n    \n    %% DCA Bot - 4 entities\n    BOT ||--o| DCA_BOT_CONFIG : \"has config\"\n    BOT ||--o| DCA_BOT_HISTORICAL_DATA : \"has history\"\n    BOT ||--o{ DCA_BOT_ORDERS : \"has orders\"\n    BOT ||--o| DCA_BOT_STATISTIC : \"has statistics\"\n    \n    USER_INFO {\n        bigint id PK\n        varchar username\n        varchar email\n        varchar password\n    }\n    \n    USER_API_KEY {\n        bigint id PK\n        bigint user_id FK\n        varchar exchange\n        varchar api_key\n        varchar api_secret\n        varchar passphrase\n    }\n    \n    BOT {\n        varchar id PK\n        varchar name\n        varchar bot_status\n        bigint user_id FK\n        bigint api_key_id FK\n        varchar bot_strategy \"GRID | DCA\"\n        timestamp created_at\n        timestamp updated_at\n    }\n    \n    BOT_ASSIGNMENTS {\n        bigint id PK\n        varchar bot_id UK\n        varchar server_id FK\n        varchar status \"ACTIVE | INACTIVE\"\n        bigint version\n        timestamp created_at\n        timestamp updated_at\n    }\n    \n    BOT_SERVERS {\n        varchar server_id PK \"UUID from ENV\"\n        varchar status \"ACTIVE | INACTIVE | UNHEALTHY\"\n        integer max_bots\n        bigint version\n        timestamp created_at\n        timestamp updated_at\n    }\n    \n    GRID_BOT_CONFIG {\n        varchar id PK\n        varchar bot_id FK\n        varchar trading_pair\n        integer leverage\n        integer max_order_count\n        decimal grid_step\n        decimal amount\n        decimal target_distance\n    }\n    \n    GRID_BOT_HISTORICAL_DATA {\n        varchar id PK\n        varchar bot_id FK\n        jsonb snapshot_data\n        timestamp created_at\n    }\n    \n    GRID_BOT_ORDERS {\n        varchar id PK\n        varchar bot_id FK\n        varchar order_type\n        decimal price\n        decimal quantity\n        varchar status\n        varchar exchange_order_id\n        timestamp created_at\n        timestamp filled_at\n    }\n    \n    GRID_BOT_STATISTIC {\n        varchar id PK\n        varchar bot_id FK\n        decimal total_profit\n        decimal today_profit\n        integer current_order_count\n        integer completed_orders_count\n        decimal avg_buy_price\n        decimal unrealized_pnl\n        decimal realized_pnl\n        bigint version\n        timestamp updated_at\n    }\n    \n    DCA_BOT_CONFIG {\n        varchar id PK\n        varchar bot_id FK\n        varchar trading_pair\n        integer leverage\n        decimal first_order_amount\n        decimal safety_order_amount\n        decimal price_deviation\n        decimal safety_order_step_scale\n    }\n    \n    DCA_BOT_HISTORICAL_DATA {\n        varchar id PK\n        varchar bot_id FK\n        jsonb snapshot_data\n        timestamp created_at\n    }\n    \n    DCA_BOT_ORDERS {\n        varchar id PK\n        varchar bot_id FK\n        varchar order_type \"BASE | SAFETY | TAKE_PROFIT\"\n        decimal price\n        decimal quantity\n        varchar status\n        varchar exchange_order_id\n        timestamp created_at\n        timestamp filled_at\n    }\n    \n    DCA_BOT_STATISTIC {\n        varchar id PK\n        varchar bot_id FK\n        decimal total_profit\n        decimal today_profit\n        integer safety_orders_count\n        integer completed_deals_count\n        decimal avg_entry_price\n        decimal unrealized_pnl\n        decimal realized_pnl\n        bigint version\n        timestamp updated_at\n    }\n```\n\n## \uD83D\uDE80 Сравнение: LoadBalancer vs Kafka\n\n| Критерий | LoadBalancer (старая архитектура) | Kafka (новая архитектура) |\n|----------|-----------------------------------|---------------------------|\n| **Сложность** | Высокая (отдельный сервис) | Низкая (только Kafka) |\n| **Идентификация** | HTTP endpoints + IP | UUID в ENV переменной |\n| **Kafka трафик** | ~5 KB на событие | ~120 bytes на событие |\n| **Запись ордеров** | Через LoadBalancer API | Прямо в БД |\n| **Race conditions** | Нужна ручная блокировка | Optimistic locking |\n| **Масштабирование** | Сложное | Простое (добавить consumer) |\n| **Monitoring** | HTTP polling | Kafka heartbeat (кеш) |\n| **Отказоустойчивость** | Single point of failure | Distributed (Kafka) |\n| **Канареечные деплои** | Не реализовано | Готово через Kafka |\n| **Настройка сервера** | API keys, endpoints | Один ENV: BOT_SERVER_ID |\n\n---\n\n## \uD83D\uDCDD TODO: План реализации\n\n### Этап 1: База данных ✅\n- [x] Создать миграцию для версионирования\n- [x] Добавить `version` в Entity классы\n- [x] Обновить Repository методы\n\n### Этап 2: Kafka в RTF\n- [ ] Настроить Kafka Producer\n- [ ] Настроить Kafka Consumer (heartbeat)\n- [ ] Создать события для bot-commands\n- [ ] Реализовать публикацию событий при CREATE/UPDATE/DELETE\n\n### Этап 3: RTF сервисы\n- [ ] Сервис выбора сервера (least loaded)\n- [ ] Consumer для heartbeat\n- [ ] Мониторинг мертвых серверов\n- [ ] Переназначение orphaned ботов\n\n### Этап 4: Bot-server (Python)\n- [ ] Kafka Consumer для команд\n- [ ] Загрузка конфигурации из БД\n- [ ] Запись ордеров в БД\n- [ ] Обновление статистики (с версионированием!)\n- [ ] Heartbeat producer\n\n### Этап 5: Тестирование\n- [ ] Race conditions (параллельные обновления)\n- [ ] Сбой сервера (переназначение ботов)\n- [ ] Kafka downtime (очередь команд)\n- [ ] Нагрузочное тестирование\n\n---\n\n\n",
    "content" : "I've created a comprehensive enhanced specification that builds upon the existing documentation. The specification includes:\n\n1. **Complete Product Brief** - Goal, context, and problem statement\n2. **Detailed System Actors** - All components with their roles and responsibilities\n3. **Comprehensive User Stories** - 14 detailed stories with acceptance criteria covering bot management, server management, trading operations, and system administration\n4. **Non-Functional Requirements** - Performance, reliability, security, and operational requirements\n5. **Clear Out of Scope** - Explicit exclusions for Version 1.0\n6. **Open Questions** - Technical, operational, business, and implementation questions\n7. **Technical Implementation Details** - Added sections on Kafka configuration, database schema, bot server implementation, monitoring, deployment, testing, security, and performance optimization\n\nThe specification is now a complete blueprint for implementing the RTF Platform with Kafka Architecture, providing both high-level architectural guidance and specific implementation details.",
    "approvalStatus" : "PENDING_APPROVAL",
    "feedback" : null,
    "createdAt" : "2026-02-23T18:56:40.330488800Z",
    "updatedAt" : "2026-02-23T19:01:46.375093600Z"
  },
  "b4240915-fa14-4501-9297-e19336e81258" : {
    "id" : "b4240915-fa14-4501-9297-e19336e81258",
    "projectId" : "40e94b0e-f7a6-46d6-9dfb-b0c13d8fde11",
    "rawInput" : "# \uD83D\uDE80 RTF Platform - Kafka Architecture\n\n## \uD83D\uDCCB Оглавление\n\n1. [Обзор архитектуры](#обзор-архитектуры)\n2. [Компоненты системы](#компоненты-системы)\n3. [Структура Kafka Topics](#структура-kafka-topics)\n4. [Потоки данных](#потоки-данных)\n5. [Версионирование и защита от race conditions](#версионирование)\n6. [Структура БД](#структура-бд)\n7. [Конфигурация](#конфигурация)\n\n---\n\n## \uD83C\uDFAF Обзор архитектуры\n\nАрхитектура построена на принципах **event-driven** взаимодействия через **Apache Kafka**, заменяя сложный LoadBalancer простой и эффективной системой обмена сообщениями.\n\n### Ключевые принципы:\n\n- ✅ **Kafka вместо LoadBalancer** - минимальные сообщения (только ID + команда)\n- ✅ **Версионирование (@Version)** - защита от грязных записей\n- ✅ **БД как единственный источник правды** - конфигурации хранятся в БД\n- ✅ **Боты пишут напрямую в БД** - ордера и статистика без промежуточных слоев\n- ✅ **Готовность к масштабированию** - легко добавлять новые серверы\n- ✅ **Идентификация через ENV** - каждый сервер имеет уникальный `BOT_SERVER_ID` в переменных окружения\n\n### \uD83D\uDD11 Идентификация серверов:\n\nКаждый bot-сервер имеет **уникальный ID в ENV переменной** `BOT_SERVER_ID`:\n\n1. **При деплое** - вручную прописывается UUID в `.env` файл или docker-compose\n2. **RTF** назначает бота конкретному серверу (записывает `server_id` в `bot_instances.ec2_id`)\n3. **Kafka сообщения** содержат `serverId` - бот-сервер проверяет \"это мне?\" и обрабатывает только свои команды\n4. **При восстановлении** - сервер загружает из БД всех ботов, где `ec2_id = MY_SERVER_ID`\n\n**Пример:**\n```bash\n# Server 1: .env\nBOT_SERVER_ID=550e8400-e29b-41d4-a716-446655440001\n\n# Server 2: .env\nBOT_SERVER_ID=550e8400-e29b-41d4-a716-446655440002\n```\n\n---\n\n## \uD83C\uDFD7️ Компоненты системы\n\n```mermaid\ngraph TB\n    subgraph Frontend\n        F[React Frontend<br/>Port 3000]\n    end\n    \n    subgraph RTF[RTF Backend - Spring Boot 8091]\n        API[REST API]\n        BM[Bot Management]\n        KP[Kafka Producer]\n        KC[Kafka Consumer]\n        MON[Server Monitor]\n    end\n    \n    subgraph Kafka[Apache Kafka - Port 9092]\n        T1[bot-commands]\n        T2[server-heartbeat]\n    end\n    \n    subgraph BotServers[Bot Servers - EC2 Python]\n        BS1[Bot Server 1<br/>Port 6969]\n        BS2[Bot Server 2<br/>Port 6969]\n        BS3[Bot Server N<br/>Port 6969]\n    end\n    \n    subgraph Database[Aurora DSQL]\n        DB[(PostgreSQL)]\n    end\n    \n    F -->|HTTP/REST| API\n    API --> BM\n    BM -->|Publish Events| KP\n    KP -->|bot.started<br/>bot.stopped<br/>bot.updated<br/>bot.closeAllPositions| T1\n    \n    BS1 -->|Heartbeat| T2\n    BS2 -->|Heartbeat| T2\n    BS3 -->|Heartbeat| T2\n    \n    T2 -->|Consume| KC\n    KC --> MON\n    \n    T1 -->|Consume| BS1\n    T1 -->|Consume| BS2\n    T1 -->|Consume| BS3\n    \n    BM -.->|READ/WRITE<br/>bot, config| DB\n    MON -.->|Cache<br/>heartbeat| DB\n    BS1 -.->|READ config<br/>WRITE orders/stats| DB\n    BS2 -.->|READ config<br/>WRITE orders/stats| DB\n    BS3 -.->|READ config<br/>WRITE orders/stats| DB\n    \n    style RTF fill:#e1f5ff\n    style Kafka fill:#fff3e0\n    style BotServers fill:#f3e5f5\n    style Database fill:#e8f5e9\n```\n\n---\n\n## \uD83D\uDCE8 Структура Kafka Topics\n\n### Topic 1: `bot-commands` (RTF → Bot-servers)\n\nКоманды для управления ботами. **Минимальные сообщения - только ID!**\n\n**Отправляются через Kafka (4 события):**\n- ✅ `bot.started` - запустить бота\n- ✅ `bot.stopped` - остановить бота\n- ✅ `bot.updated` - обновить конфигурацию\n- ✅ `bot.closeAllPositions` - закрыть позиции\n\n**НЕ отправляются через Kafka:**\n- ❌ `bot.created` - только сохранение в БД\n- ❌ `bot.deleted` - только удаление из БД\n\n**Формат событий:**\n\n```json\n{\n  \"eventType\": \"bot.started | bot.stopped | bot.updated | bot.closeAllPositions\",\n  \"botId\": \"bot-456\",\n  \"serverId\": \"550e8400-e29b-41d4-a716-446655440001\"\n}\n```\n\n**Размер:** ~100 bytes (минимум данных!)\n\n---\n\n### Topic 2: `server-heartbeat` (Bot-servers → RTF)\n\nМониторинг состояния серверов каждые 30 секунд.\n\n```mermaid\ngraph LR\n    subgraph Bot Servers\n        BS1[Server 1]\n        BS2[Server 2]\n        BS3[Server N]\n    end\n    \n    subgraph Kafka\n        HB[server-heartbeat topic]\n    end\n    \n    subgraph RTF\n        MON[Monitor Service]\n        DB[(Database)]\n    end\n    \n    BS1 -->|Every 30s| HB\n    BS2 -->|Every 30s| HB\n    BS3 -->|Every 30s| HB\n    \n    HB --> MON\n    MON -->|Save to CACHE| MON\n    MON -->|Check dead servers| DB\n    MON -.->|Reassign bots| HB\n```\n\n**Формат:**\n\n```json\n{\n  \"eventType\": \"server.heartbeat\",\n  \"ec2Id\": \"550e8400-e29b-41d4-a716-446655440001\",\n  \"botId\": \"bot-456\"\n}\n```\n\n---\n\n## \uD83D\uDD04 Потоки данных\n\n### Flow 1: Создание бота (БЕЗ Kafka!)\n\n```mermaid\nsequenceDiagram\n    participant Frontend\n    participant RTF\n    participant DB\n    \n    Frontend->>RTF: POST /api/bot/create\n    \n    Note over RTF: Select least loaded server\n    RTF->>DB: SELECT FROM bot_servers<br/>WHERE status='ACTIVE'<br/>ORDER BY load\n    DB-->>RTF: serverId: \"550e8400-...\"\n    \n    Note over RTF: Transaction BEGIN\n    RTF->>DB: INSERT INTO bot\n    RTF->>DB: INSERT INTO grid_bot_config\n    RTF->>DB: INSERT INTO bot_assignments<br/>(bot_id, server_id, status='INACTIVE')\n    RTF->>DB: INSERT INTO grid_bot_statistic\n    Note over RTF: COMMIT\n    \n    RTF-->>Frontend: 200 OK {botId}\n    \n    Note over RTF,DB: ❌ Kafka НЕ используется!<br/>Бот только сохранен в БД<br/>status = INACTIVE\n```\n\n---\n\n### Flow 2: Запуск бота (через Kafka!)\n\n```mermaid\nsequenceDiagram\n    participant Frontend\n    participant RTF\n    participant DB\n    participant Kafka\n    participant BotServer\n    \n    Frontend->>RTF: POST /api/bot/start\n    \n    RTF->>DB: SELECT server_id FROM bot_assignments<br/>WHERE bot_id=?\n    DB-->>RTF: serverId\n    \n    RTF->>DB: UPDATE bot<br/>SET bot_status='ACTIVE'\n    \n    RTF->>Kafka: Publish bot.started<br/>{botId, serverId}\n    RTF-->>Frontend: 200 OK\n    \n    Kafka->>BotServer: Deliver bot.started\n    \n    alt serverId == MY_SERVER_ID\n        alt Bot in memory\n            BotServer->>BotServer: Activate bot\n            BotServer->>BotServer: Start trading\n        else Bot NOT in memory\n            BotServer->>DB: SELECT bot, config, api_key\n            DB-->>BotServer: Full configuration\n            BotServer->>BotServer: Initialize bot\n            BotServer->>BotServer: Start trading\n        end\n        BotServer->>DB: UPDATE bot_assignments<br/>status='ACTIVE'\n    else serverId != MY_SERVER_ID\n        BotServer->>BotServer: Ignore (not my bot)\n    end\n```\n\n---\n\n### Flow 3: Обновление конфигурации\n\n```mermaid\nsequenceDiagram\n    participant Frontend\n    participant RTF\n    participant DB\n    participant Kafka\n    participant BotServer\n    \n    Frontend->>RTF: POST /api/bot/update\n    \n    RTF->>DB: SELECT server_id FROM bot_assignments<br/>WHERE bot_id=?\n    DB-->>RTF: serverId\n    \n    Note over RTF: Transaction with versioning\n    RTF->>DB: UPDATE bot<br/>WHERE id=? AND version=?\n    RTF->>DB: UPDATE grid_bot_config<br/>WHERE id=?\n    Note over RTF: COMMIT (version++)\n    \n    RTF->>Kafka: Publish bot.updated<br/>{botId, serverId}\n    RTF-->>Frontend: 200 OK\n    \n    Kafka->>BotServer: Deliver bot.updated\n    \n    alt serverId == MY_SERVER_ID\n        BotServer->>DB: SELECT grid_bot_config<br/>WHERE id=?\n        DB-->>BotServer: New configuration\n        BotServer->>BotServer: Apply new config<br/>to running bot\n    else serverId != MY_SERVER_ID\n        BotServer->>BotServer: Ignore (not my bot)\n    end\n```\n\n---\n\n### Flow 3: Торговля и запись ордеров\n\n```mermaid\nsequenceDiagram\n    participant Exchange\n    participant BotServer\n    participant DB\n    participant RTF\n    participant Frontend\n    \n    Note over BotServer: Bot is trading\n    \n    BotServer->>Exchange: Place order\n    Exchange-->>BotServer: Order filled\n    \n    BotServer->>DB: INSERT INTO grid_bot_order<br/>(id, bot_id, price, quantity, ...)\n    \n    BotServer->>DB: UPDATE grid_bot_statistic<br/>SET total_profit=?, ...<br/>WHERE bot_id=? AND version=?\n    \n    alt Version conflict\n        DB-->>BotServer: 0 rows updated\n        Note over BotServer: Retry with new version\n        BotServer->>DB: SELECT version\n        BotServer->>DB: UPDATE with correct version\n    else Success\n        DB-->>BotServer: 1 row updated\n    end\n    \n    Frontend->>RTF: GET /api/bot/{id}/statistics\n    RTF->>DB: SELECT FROM grid_bot_statistic\n    DB-->>RTF: Current statistics\n    RTF-->>Frontend: Statistics data\n```\n\n---\n\n### Flow 4: Мониторинг и переназначение при сбое\n\n```mermaid\nsequenceDiagram\n    participant BotServer\n    participant Kafka\n    participant RTF\n    participant DB\n    \n    loop Every 30 seconds\n        BotServer->>Kafka: Publish heartbeat<br/>{serverId, activeBots, maxBots}\n        Kafka->>RTF: Deliver heartbeat\n        RTF->>RTF: Save to CACHE<br/>(NOT to Database!)\n    end\n    \n    Note over RTF: Heartbeat в КЕШе!<br/>Экономия операций БД\n    \n    Note over RTF: Scheduled check every 60s<br/>(проверка КЕША!)\n    RTF->>RTF: Check CACHE<br/>timestamp < NOW() - 2 minutes\n    Note over RTF: Dead servers list from CACHE\n    \n    alt Dead server found\n        RTF->>DB: SELECT bots FROM bot_assignments<br/>WHERE server_id = dead_server_id\n        DB-->>RTF: Orphaned bots list\n        \n        loop For each orphaned bot\n            RTF->>DB: SELECT least loaded server\n            RTF->>DB: UPDATE bot_assignments<br/>SET server_id=new_server<br/>WHERE bot_id=? AND version=?\n            RTF->>Kafka: Publish bot.started<br/>{botId, newServerId}\n        end\n        \n        RTF->>DB: UPDATE bot_servers<br/>SET status='UNHEALTHY'<br/>WHERE server_id = dead_server_id\n    end\n```\n\n---\n\n## \uD83D\uDD12 Версионирование и защита от race conditions\n\nИспользуем **Optimistic Locking** через `@Version` (JPA) для предотвращения грязных записей.\n\n### Таблицы с версионированием:\n\n```mermaid\nerDiagram\n    BOT_ASSIGNMENTS {\n        bigint id PK\n        varchar bot_id UK\n        varchar server_id FK\n        varchar status \"ACTIVE | INACTIVE\"\n        bigint version \"Optimistic Lock\"\n    }\n    \n    BOT_SERVERS {\n        varchar server_id PK \"UUID from ENV\"\n        varchar status \"ACTIVE | INACTIVE | UNHEALTHY\"\n        integer max_bots\n        bigint version \"Optimistic Lock\"\n    }\n    \n    GRID_BOT_STATISTIC {\n        varchar id PK\n        decimal total_profit\n        decimal today_profit\n        integer current_order_count\n        bigint version \"Optimistic Lock\"\n    }\n    \n    BOT_ASSIGNMENTS }o--|| BOT_SERVERS : \"assigned to\"\n    BOT_ASSIGNMENTS ||--|| GRID_BOT_STATISTIC : \"has statistics\"\n```\n\n### Как работает версионирование:\n\n```mermaid\nsequenceDiagram\n    participant Process1\n    participant Process2\n    participant DB\n    \n    Note over Process1,Process2: Parallel updates to same record\n    \n    Process1->>DB: SELECT * WHERE id=1\n    Note over DB: version = 5\n    DB-->>Process1: Record (version=5)\n    \n    Process2->>DB: SELECT * WHERE id=1\n    Note over DB: version = 5\n    DB-->>Process2: Record (version=5)\n    \n    Process1->>DB: UPDATE ... <br/>WHERE id=1 AND version=5\n    Note over DB: version = 6\n    DB-->>Process1: ✅ Success (1 row)\n    \n    Process2->>DB: UPDATE ... <br/>WHERE id=1 AND version=5\n    Note over DB: version already 6!\n    DB-->>Process2: ❌ OptimisticLockException<br/>(0 rows)\n    \n    Process2->>Process2: Retry operation\n    Process2->>DB: SELECT * WHERE id=1\n    DB-->>Process2: Record (version=6)\n    Process2->>DB: UPDATE ... <br/>WHERE id=1 AND version=6\n    DB-->>Process2: ✅ Success\n```\n\n### Где используется:\n\n| Операция | Таблица | Кто обновляет | Защита от |\n|----------|---------|---------------|-----------|\n| Назначение бота на сервер | `bot_assignments` | RTF | Двойное назначение |\n| Обновление статистики | `grid_bot_statistic` | Bot-server | Параллельные обновления |\n| Обновление статуса сервера | `bot_servers` | RTF (heartbeat) | Конфликты при мониторинге |\n| Переназначение бота | `bot_assignments` | RTF (monitor) | Двойное переназначение |\n\n---\n\n## \uD83D\uDDC4️ Структура БД\n\n### Entity Relationship Diagram\n\n```mermaid\nerDiagram\n    USER_INFO ||--o{ BOT : owns\n    USER_INFO ||--o{ USER_API_KEY : has\n    \n    BOT ||--|| BOT_ASSIGNMENTS : assignment\n    BOT }o--|| USER_API_KEY : uses\n    BOT_ASSIGNMENTS }o--|| BOT_SERVERS : \"runs on\"\n    \n    %% Grid Bot - 4 entities\n    BOT ||--o| GRID_BOT_CONFIG : \"has config\"\n    BOT ||--o| GRID_BOT_HISTORICAL_DATA : \"has history\"\n    BOT ||--o{ GRID_BOT_ORDERS : \"has orders\"\n    BOT ||--o| GRID_BOT_STATISTIC : \"has statistics\"\n    \n    %% DCA Bot - 4 entities\n    BOT ||--o| DCA_BOT_CONFIG : \"has config\"\n    BOT ||--o| DCA_BOT_HISTORICAL_DATA : \"has history\"\n    BOT ||--o{ DCA_BOT_ORDERS : \"has orders\"\n    BOT ||--o| DCA_BOT_STATISTIC : \"has statistics\"\n    \n    USER_INFO {\n        bigint id PK\n        varchar username\n        varchar email\n        varchar password\n    }\n    \n    USER_API_KEY {\n        bigint id PK\n        bigint user_id FK\n        varchar exchange\n        varchar api_key\n        varchar api_secret\n        varchar passphrase\n    }\n    \n    BOT {\n        varchar id PK\n        varchar name\n        varchar bot_status\n        bigint user_id FK\n        bigint api_key_id FK\n        varchar bot_strategy \"GRID | DCA\"\n        timestamp created_at\n        timestamp updated_at\n    }\n    \n    BOT_ASSIGNMENTS {\n        bigint id PK\n        varchar bot_id UK\n        varchar server_id FK\n        varchar status \"ACTIVE | INACTIVE\"\n        bigint version\n        timestamp created_at\n        timestamp updated_at\n    }\n    \n    BOT_SERVERS {\n        varchar server_id PK \"UUID from ENV\"\n        varchar status \"ACTIVE | INACTIVE | UNHEALTHY\"\n        integer max_bots\n        bigint version\n        timestamp created_at\n        timestamp updated_at\n    }\n    \n    GRID_BOT_CONFIG {\n        varchar id PK\n        varchar bot_id FK\n        varchar trading_pair\n        integer leverage\n        integer max_order_count\n        decimal grid_step\n        decimal amount\n        decimal target_distance\n    }\n    \n    GRID_BOT_HISTORICAL_DATA {\n        varchar id PK\n        varchar bot_id FK\n        jsonb snapshot_data\n        timestamp created_at\n    }\n    \n    GRID_BOT_ORDERS {\n        varchar id PK\n        varchar bot_id FK\n        varchar order_type\n        decimal price\n        decimal quantity\n        varchar status\n        varchar exchange_order_id\n        timestamp created_at\n        timestamp filled_at\n    }\n    \n    GRID_BOT_STATISTIC {\n        varchar id PK\n        varchar bot_id FK\n        decimal total_profit\n        decimal today_profit\n        integer current_order_count\n        integer completed_orders_count\n        decimal avg_buy_price\n        decimal unrealized_pnl\n        decimal realized_pnl\n        bigint version\n        timestamp updated_at\n    }\n    \n    DCA_BOT_CONFIG {\n        varchar id PK\n        varchar bot_id FK\n        varchar trading_pair\n        integer leverage\n        decimal first_order_amount\n        decimal safety_order_amount\n        decimal price_deviation\n        decimal safety_order_step_scale\n    }\n    \n    DCA_BOT_HISTORICAL_DATA {\n        varchar id PK\n        varchar bot_id FK\n        jsonb snapshot_data\n        timestamp created_at\n    }\n    \n    DCA_BOT_ORDERS {\n        varchar id PK\n        varchar bot_id FK\n        varchar order_type \"BASE | SAFETY | TAKE_PROFIT\"\n        decimal price\n        decimal quantity\n        varchar status\n        varchar exchange_order_id\n        timestamp created_at\n        timestamp filled_at\n    }\n    \n    DCA_BOT_STATISTIC {\n        varchar id PK\n        varchar bot_id FK\n        decimal total_profit\n        decimal today_profit\n        integer safety_orders_count\n        integer completed_deals_count\n        decimal avg_entry_price\n        decimal unrealized_pnl\n        decimal realized_pnl\n        bigint version\n        timestamp updated_at\n    }\n```\n\n## \uD83D\uDE80 Сравнение: LoadBalancer vs Kafka\n\n| Критерий | LoadBalancer (старая архитектура) | Kafka (новая архитектура) |\n|----------|-----------------------------------|---------------------------|\n| **Сложность** | Высокая (отдельный сервис) | Низкая (только Kafka) |\n| **Идентификация** | HTTP endpoints + IP | UUID в ENV переменной |\n| **Kafka трафик** | ~5 KB на событие | ~120 bytes на событие |\n| **Запись ордеров** | Через LoadBalancer API | Прямо в БД |\n| **Race conditions** | Нужна ручная блокировка | Optimistic locking |\n| **Масштабирование** | Сложное | Простое (добавить consumer) |\n| **Monitoring** | HTTP polling | Kafka heartbeat (кеш) |\n| **Отказоустойчивость** | Single point of failure | Distributed (Kafka) |\n| **Канареечные деплои** | Не реализовано | Готово через Kafka |\n| **Настройка сервера** | API keys, endpoints | Один ENV: BOT_SERVER_ID |\n\n---\n\n## \uD83D\uDCDD TODO: План реализации\n\n### Этап 1: База данных ✅\n- [x] Создать миграцию для версионирования\n- [x] Добавить `version` в Entity классы\n- [x] Обновить Repository методы\n\n### Этап 2: Kafka в RTF\n- [ ] Настроить Kafka Producer\n- [ ] Настроить Kafka Consumer (heartbeat)\n- [ ] Создать события для bot-commands\n- [ ] Реализовать публикацию событий при CREATE/UPDATE/DELETE\n\n### Этап 3: RTF сервисы\n- [ ] Сервис выбора сервера (least loaded)\n- [ ] Consumer для heartbeat\n- [ ] Мониторинг мертвых серверов\n- [ ] Переназначение orphaned ботов\n\n### Этап 4: Bot-server (Python)\n- [ ] Kafka Consumer для команд\n- [ ] Загрузка конфигурации из БД\n- [ ] Запись ордеров в БД\n- [ ] Обновление статистики (с версионированием!)\n- [ ] Heartbeat producer\n\n### Этап 5: Тестирование\n- [ ] Race conditions (параллельные обновления)\n- [ ] Сбой сервера (переназначение ботов)\n- [ ] Kafka downtime (очередь команд)\n- [ ] Нагрузочное тестирование\n\n---\n\n\n",
    "content" : "⚠️ BA Agent failed: Project not found: 40e94b0e-f7a6-46d6-9dfb-b0c13d8fde11",
    "approvalStatus" : "DRAFT",
    "feedback" : null,
    "createdAt" : "2026-02-23T18:55:49.950585200Z",
    "updatedAt" : "2026-02-23T18:55:49.950585200Z"
  },
  "b5ed0186-3e25-44a6-ad7a-eb172b45942b" : {
    "id" : "b5ed0186-3e25-44a6-ad7a-eb172b45942b",
    "projectId" : "40e94b0e-f7a6-46d6-9dfb-b0c13d8fde11",
    "rawInput" : "# \uD83D\uDE80 RTF Platform - Kafka Architecture\n\n## \uD83D\uDCCB Оглавление\n\n1. [Обзор архитектуры](#обзор-архитектуры)\n2. [Компоненты системы](#компоненты-системы)\n3. [Структура Kafka Topics](#структура-kafka-topics)\n4. [Потоки данных](#потоки-данных)\n5. [Версионирование и защита от race conditions](#версионирование)\n6. [Структура БД](#структура-бд)\n7. [Конфигурация](#конфигурация)\n\n---\n\n## \uD83C\uDFAF Обзор архитектуры\n\nАрхитектура построена на принципах **event-driven** взаимодействия через **Apache Kafka**, заменяя сложный LoadBalancer простой и эффективной системой обмена сообщениями.\n\n### Ключевые принципы:\n\n- ✅ **Kafka вместо LoadBalancer** - минимальные сообщения (только ID + команда)\n- ✅ **Версионирование (@Version)** - защита от грязных записей\n- ✅ **БД как единственный источник правды** - конфигурации хранятся в БД\n- ✅ **Боты пишут напрямую в БД** - ордера и статистика без промежуточных слоев\n- ✅ **Готовность к масштабированию** - легко добавлять новые серверы\n- ✅ **Идентификация через ENV** - каждый сервер имеет уникальный `BOT_SERVER_ID` в переменных окружения\n\n### \uD83D\uDD11 Идентификация серверов:\n\nКаждый bot-сервер имеет **уникальный ID в ENV переменной** `BOT_SERVER_ID`:\n\n1. **При деплое** - вручную прописывается UUID в `.env` файл или docker-compose\n2. **RTF** назначает бота конкретному серверу (записывает `server_id` в `bot_instances.ec2_id`)\n3. **Kafka сообщения** содержат `serverId` - бот-сервер проверяет \"это мне?\" и обрабатывает только свои команды\n4. **При восстановлении** - сервер загружает из БД всех ботов, где `ec2_id = MY_SERVER_ID`\n\n**Пример:**\n```bash\n# Server 1: .env\nBOT_SERVER_ID=550e8400-e29b-41d4-a716-446655440001\n\n# Server 2: .env\nBOT_SERVER_ID=550e8400-e29b-41d4-a716-446655440002\n```\n\n---\n\n## \uD83C\uDFD7️ Компоненты системы\n\n```mermaid\ngraph TB\n    subgraph Frontend\n        F[React Frontend<br/>Port 3000]\n    end\n    \n    subgraph RTF[RTF Backend - Spring Boot 8091]\n        API[REST API]\n        BM[Bot Management]\n        KP[Kafka Producer]\n        KC[Kafka Consumer]\n        MON[Server Monitor]\n    end\n    \n    subgraph Kafka[Apache Kafka - Port 9092]\n        T1[bot-commands]\n        T2[server-heartbeat]\n    end\n    \n    subgraph BotServers[Bot Servers - EC2 Python]\n        BS1[Bot Server 1<br/>Port 6969]\n        BS2[Bot Server 2<br/>Port 6969]\n        BS3[Bot Server N<br/>Port 6969]\n    end\n    \n    subgraph Database[Aurora DSQL]\n        DB[(PostgreSQL)]\n    end\n    \n    F -->|HTTP/REST| API\n    API --> BM\n    BM -->|Publish Events| KP\n    KP -->|bot.started<br/>bot.stopped<br/>bot.updated<br/>bot.closeAllPositions| T1\n    \n    BS1 -->|Heartbeat| T2\n    BS2 -->|Heartbeat| T2\n    BS3 -->|Heartbeat| T2\n    \n    T2 -->|Consume| KC\n    KC --> MON\n    \n    T1 -->|Consume| BS1\n    T1 -->|Consume| BS2\n    T1 -->|Consume| BS3\n    \n    BM -.->|READ/WRITE<br/>bot, config| DB\n    MON -.->|Cache<br/>heartbeat| DB\n    BS1 -.->|READ config<br/>WRITE orders/stats| DB\n    BS2 -.->|READ config<br/>WRITE orders/stats| DB\n    BS3 -.->|READ config<br/>WRITE orders/stats| DB\n    \n    style RTF fill:#e1f5ff\n    style Kafka fill:#fff3e0\n    style BotServers fill:#f3e5f5\n    style Database fill:#e8f5e9\n```\n\n---\n\n## \uD83D\uDCE8 Структура Kafka Topics\n\n### Topic 1: `bot-commands` (RTF → Bot-servers)\n\nКоманды для управления ботами. **Минимальные сообщения - только ID!**\n\n**Отправляются через Kafka (4 события):**\n- ✅ `bot.started` - запустить бота\n- ✅ `bot.stopped` - остановить бота\n- ✅ `bot.updated` - обновить конфигурацию\n- ✅ `bot.closeAllPositions` - закрыть позиции\n\n**НЕ отправляются через Kafka:**\n- ❌ `bot.created` - только сохранение в БД\n- ❌ `bot.deleted` - только удаление из БД\n\n**Формат событий:**\n\n```json\n{\n  \"eventType\": \"bot.started | bot.stopped | bot.updated | bot.closeAllPositions\",\n  \"botId\": \"bot-456\",\n  \"serverId\": \"550e8400-e29b-41d4-a716-446655440001\"\n}\n```\n\n**Размер:** ~100 bytes (минимум данных!)\n\n---\n\n### Topic 2: `server-heartbeat` (Bot-servers → RTF)\n\nМониторинг состояния серверов каждые 30 секунд.\n\n```mermaid\ngraph LR\n    subgraph Bot Servers\n        BS1[Server 1]\n        BS2[Server 2]\n        BS3[Server N]\n    end\n    \n    subgraph Kafka\n        HB[server-heartbeat topic]\n    end\n    \n    subgraph RTF\n        MON[Monitor Service]\n        DB[(Database)]\n    end\n    \n    BS1 -->|Every 30s| HB\n    BS2 -->|Every 30s| HB\n    BS3 -->|Every 30s| HB\n    \n    HB --> MON\n    MON -->|Save to CACHE| MON\n    MON -->|Check dead servers| DB\n    MON -.->|Reassign bots| HB\n```\n\n**Формат:**\n\n```json\n{\n  \"eventType\": \"server.heartbeat\",\n  \"ec2Id\": \"550e8400-e29b-41d4-a716-446655440001\",\n  \"botId\": \"bot-456\"\n}\n```\n\n---\n\n## \uD83D\uDD04 Потоки данных\n\n### Flow 1: Создание бота (БЕЗ Kafka!)\n\n```mermaid\nsequenceDiagram\n    participant Frontend\n    participant RTF\n    participant DB\n    \n    Frontend->>RTF: POST /api/bot/create\n    \n    Note over RTF: Select least loaded server\n    RTF->>DB: SELECT FROM bot_servers<br/>WHERE status='ACTIVE'<br/>ORDER BY load\n    DB-->>RTF: serverId: \"550e8400-...\"\n    \n    Note over RTF: Transaction BEGIN\n    RTF->>DB: INSERT INTO bot\n    RTF->>DB: INSERT INTO grid_bot_config\n    RTF->>DB: INSERT INTO bot_assignments<br/>(bot_id, server_id, status='INACTIVE')\n    RTF->>DB: INSERT INTO grid_bot_statistic\n    Note over RTF: COMMIT\n    \n    RTF-->>Frontend: 200 OK {botId}\n    \n    Note over RTF,DB: ❌ Kafka НЕ используется!<br/>Бот только сохранен в БД<br/>status = INACTIVE\n```\n\n---\n\n### Flow 2: Запуск бота (через Kafka!)\n\n```mermaid\nsequenceDiagram\n    participant Frontend\n    participant RTF\n    participant DB\n    participant Kafka\n    participant BotServer\n    \n    Frontend->>RTF: POST /api/bot/start\n    \n    RTF->>DB: SELECT server_id FROM bot_assignments<br/>WHERE bot_id=?\n    DB-->>RTF: serverId\n    \n    RTF->>DB: UPDATE bot<br/>SET bot_status='ACTIVE'\n    \n    RTF->>Kafka: Publish bot.started<br/>{botId, serverId}\n    RTF-->>Frontend: 200 OK\n    \n    Kafka->>BotServer: Deliver bot.started\n    \n    alt serverId == MY_SERVER_ID\n        alt Bot in memory\n            BotServer->>BotServer: Activate bot\n            BotServer->>BotServer: Start trading\n        else Bot NOT in memory\n            BotServer->>DB: SELECT bot, config, api_key\n            DB-->>BotServer: Full configuration\n            BotServer->>BotServer: Initialize bot\n            BotServer->>BotServer: Start trading\n        end\n        BotServer->>DB: UPDATE bot_assignments<br/>status='ACTIVE'\n    else serverId != MY_SERVER_ID\n        BotServer->>BotServer: Ignore (not my bot)\n    end\n```\n\n---\n\n### Flow 3: Обновление конфигурации\n\n```mermaid\nsequenceDiagram\n    participant Frontend\n    participant RTF\n    participant DB\n    participant Kafka\n    participant BotServer\n    \n    Frontend->>RTF: POST /api/bot/update\n    \n    RTF->>DB: SELECT server_id FROM bot_assignments<br/>WHERE bot_id=?\n    DB-->>RTF: serverId\n    \n    Note over RTF: Transaction with versioning\n    RTF->>DB: UPDATE bot<br/>WHERE id=? AND version=?\n    RTF->>DB: UPDATE grid_bot_config<br/>WHERE id=?\n    Note over RTF: COMMIT (version++)\n    \n    RTF->>Kafka: Publish bot.updated<br/>{botId, serverId}\n    RTF-->>Frontend: 200 OK\n    \n    Kafka->>BotServer: Deliver bot.updated\n    \n    alt serverId == MY_SERVER_ID\n        BotServer->>DB: SELECT grid_bot_config<br/>WHERE id=?\n        DB-->>BotServer: New configuration\n        BotServer->>BotServer: Apply new config<br/>to running bot\n    else serverId != MY_SERVER_ID\n        BotServer->>BotServer: Ignore (not my bot)\n    end\n```\n\n---\n\n### Flow 3: Торговля и запись ордеров\n\n```mermaid\nsequenceDiagram\n    participant Exchange\n    participant BotServer\n    participant DB\n    participant RTF\n    participant Frontend\n    \n    Note over BotServer: Bot is trading\n    \n    BotServer->>Exchange: Place order\n    Exchange-->>BotServer: Order filled\n    \n    BotServer->>DB: INSERT INTO grid_bot_order<br/>(id, bot_id, price, quantity, ...)\n    \n    BotServer->>DB: UPDATE grid_bot_statistic<br/>SET total_profit=?, ...<br/>WHERE bot_id=? AND version=?\n    \n    alt Version conflict\n        DB-->>BotServer: 0 rows updated\n        Note over BotServer: Retry with new version\n        BotServer->>DB: SELECT version\n        BotServer->>DB: UPDATE with correct version\n    else Success\n        DB-->>BotServer: 1 row updated\n    end\n    \n    Frontend->>RTF: GET /api/bot/{id}/statistics\n    RTF->>DB: SELECT FROM grid_bot_statistic\n    DB-->>RTF: Current statistics\n    RTF-->>Frontend: Statistics data\n```\n\n---\n\n### Flow 4: Мониторинг и переназначение при сбое\n\n```mermaid\nsequenceDiagram\n    participant BotServer\n    participant Kafka\n    participant RTF\n    participant DB\n    \n    loop Every 30 seconds\n        BotServer->>Kafka: Publish heartbeat<br/>{serverId, activeBots, maxBots}\n        Kafka->>RTF: Deliver heartbeat\n        RTF->>RTF: Save to CACHE<br/>(NOT to Database!)\n    end\n    \n    Note over RTF: Heartbeat в КЕШе!<br/>Экономия операций БД\n    \n    Note over RTF: Scheduled check every 60s<br/>(проверка КЕША!)\n    RTF->>RTF: Check CACHE<br/>timestamp < NOW() - 2 minutes\n    Note over RTF: Dead servers list from CACHE\n    \n    alt Dead server found\n        RTF->>DB: SELECT bots FROM bot_assignments<br/>WHERE server_id = dead_server_id\n        DB-->>RTF: Orphaned bots list\n        \n        loop For each orphaned bot\n            RTF->>DB: SELECT least loaded server\n            RTF->>DB: UPDATE bot_assignments<br/>SET server_id=new_server<br/>WHERE bot_id=? AND version=?\n            RTF->>Kafka: Publish bot.started<br/>{botId, newServerId}\n        end\n        \n        RTF->>DB: UPDATE bot_servers<br/>SET status='UNHEALTHY'<br/>WHERE server_id = dead_server_id\n    end\n```\n\n---\n\n## \uD83D\uDD12 Версионирование и защита от race conditions\n\nИспользуем **Optimistic Locking** через `@Version` (JPA) для предотвращения грязных записей.\n\n### Таблицы с версионированием:\n\n```mermaid\nerDiagram\n    BOT_ASSIGNMENTS {\n        bigint id PK\n        varchar bot_id UK\n        varchar server_id FK\n        varchar status \"ACTIVE | INACTIVE\"\n        bigint version \"Optimistic Lock\"\n    }\n    \n    BOT_SERVERS {\n        varchar server_id PK \"UUID from ENV\"\n        varchar status \"ACTIVE | INACTIVE | UNHEALTHY\"\n        integer max_bots\n        bigint version \"Optimistic Lock\"\n    }\n    \n    GRID_BOT_STATISTIC {\n        varchar id PK\n        decimal total_profit\n        decimal today_profit\n        integer current_order_count\n        bigint version \"Optimistic Lock\"\n    }\n    \n    BOT_ASSIGNMENTS }o--|| BOT_SERVERS : \"assigned to\"\n    BOT_ASSIGNMENTS ||--|| GRID_BOT_STATISTIC : \"has statistics\"\n```\n\n### Как работает версионирование:\n\n```mermaid\nsequenceDiagram\n    participant Process1\n    participant Process2\n    participant DB\n    \n    Note over Process1,Process2: Parallel updates to same record\n    \n    Process1->>DB: SELECT * WHERE id=1\n    Note over DB: version = 5\n    DB-->>Process1: Record (version=5)\n    \n    Process2->>DB: SELECT * WHERE id=1\n    Note over DB: version = 5\n    DB-->>Process2: Record (version=5)\n    \n    Process1->>DB: UPDATE ... <br/>WHERE id=1 AND version=5\n    Note over DB: version = 6\n    DB-->>Process1: ✅ Success (1 row)\n    \n    Process2->>DB: UPDATE ... <br/>WHERE id=1 AND version=5\n    Note over DB: version already 6!\n    DB-->>Process2: ❌ OptimisticLockException<br/>(0 rows)\n    \n    Process2->>Process2: Retry operation\n    Process2->>DB: SELECT * WHERE id=1\n    DB-->>Process2: Record (version=6)\n    Process2->>DB: UPDATE ... <br/>WHERE id=1 AND version=6\n    DB-->>Process2: ✅ Success\n```\n\n### Где используется:\n\n| Операция | Таблица | Кто обновляет | Защита от |\n|----------|---------|---------------|-----------|\n| Назначение бота на сервер | `bot_assignments` | RTF | Двойное назначение |\n| Обновление статистики | `grid_bot_statistic` | Bot-server | Параллельные обновления |\n| Обновление статуса сервера | `bot_servers` | RTF (heartbeat) | Конфликты при мониторинге |\n| Переназначение бота | `bot_assignments` | RTF (monitor) | Двойное переназначение |\n\n---\n\n## \uD83D\uDDC4️ Структура БД\n\n### Entity Relationship Diagram\n\n```mermaid\nerDiagram\n    USER_INFO ||--o{ BOT : owns\n    USER_INFO ||--o{ USER_API_KEY : has\n    \n    BOT ||--|| BOT_ASSIGNMENTS : assignment\n    BOT }o--|| USER_API_KEY : uses\n    BOT_ASSIGNMENTS }o--|| BOT_SERVERS : \"runs on\"\n    \n    %% Grid Bot - 4 entities\n    BOT ||--o| GRID_BOT_CONFIG : \"has config\"\n    BOT ||--o| GRID_BOT_HISTORICAL_DATA : \"has history\"\n    BOT ||--o{ GRID_BOT_ORDERS : \"has orders\"\n    BOT ||--o| GRID_BOT_STATISTIC : \"has statistics\"\n    \n    %% DCA Bot - 4 entities\n    BOT ||--o| DCA_BOT_CONFIG : \"has config\"\n    BOT ||--o| DCA_BOT_HISTORICAL_DATA : \"has history\"\n    BOT ||--o{ DCA_BOT_ORDERS : \"has orders\"\n    BOT ||--o| DCA_BOT_STATISTIC : \"has statistics\"\n    \n    USER_INFO {\n        bigint id PK\n        varchar username\n        varchar email\n        varchar password\n    }\n    \n    USER_API_KEY {\n        bigint id PK\n        bigint user_id FK\n        varchar exchange\n        varchar api_key\n        varchar api_secret\n        varchar passphrase\n    }\n    \n    BOT {\n        varchar id PK\n        varchar name\n        varchar bot_status\n        bigint user_id FK\n        bigint api_key_id FK\n        varchar bot_strategy \"GRID | DCA\"\n        timestamp created_at\n        timestamp updated_at\n    }\n    \n    BOT_ASSIGNMENTS {\n        bigint id PK\n        varchar bot_id UK\n        varchar server_id FK\n        varchar status \"ACTIVE | INACTIVE\"\n        bigint version\n        timestamp created_at\n        timestamp updated_at\n    }\n    \n    BOT_SERVERS {\n        varchar server_id PK \"UUID from ENV\"\n        varchar status \"ACTIVE | INACTIVE | UNHEALTHY\"\n        integer max_bots\n        bigint version\n        timestamp created_at\n        timestamp updated_at\n    }\n    \n    GRID_BOT_CONFIG {\n        varchar id PK\n        varchar bot_id FK\n        varchar trading_pair\n        integer leverage\n        integer max_order_count\n        decimal grid_step\n        decimal amount\n        decimal target_distance\n    }\n    \n    GRID_BOT_HISTORICAL_DATA {\n        varchar id PK\n        varchar bot_id FK\n        jsonb snapshot_data\n        timestamp created_at\n    }\n    \n    GRID_BOT_ORDERS {\n        varchar id PK\n        varchar bot_id FK\n        varchar order_type\n        decimal price\n        decimal quantity\n        varchar status\n        varchar exchange_order_id\n        timestamp created_at\n        timestamp filled_at\n    }\n    \n    GRID_BOT_STATISTIC {\n        varchar id PK\n        varchar bot_id FK\n        decimal total_profit\n        decimal today_profit\n        integer current_order_count\n        integer completed_orders_count\n        decimal avg_buy_price\n        decimal unrealized_pnl\n        decimal realized_pnl\n        bigint version\n        timestamp updated_at\n    }\n    \n    DCA_BOT_CONFIG {\n        varchar id PK\n        varchar bot_id FK\n        varchar trading_pair\n        integer leverage\n        decimal first_order_amount\n        decimal safety_order_amount\n        decimal price_deviation\n        decimal safety_order_step_scale\n    }\n    \n    DCA_BOT_HISTORICAL_DATA {\n        varchar id PK\n        varchar bot_id FK\n        jsonb snapshot_data\n        timestamp created_at\n    }\n    \n    DCA_BOT_ORDERS {\n        varchar id PK\n        varchar bot_id FK\n        varchar order_type \"BASE | SAFETY | TAKE_PROFIT\"\n        decimal price\n        decimal quantity\n        varchar status\n        varchar exchange_order_id\n        timestamp created_at\n        timestamp filled_at\n    }\n    \n    DCA_BOT_STATISTIC {\n        varchar id PK\n        varchar bot_id FK\n        decimal total_profit\n        decimal today_profit\n        integer safety_orders_count\n        integer completed_deals_count\n        decimal avg_entry_price\n        decimal unrealized_pnl\n        decimal realized_pnl\n        bigint version\n        timestamp updated_at\n    }\n```\n\n## \uD83D\uDE80 Сравнение: LoadBalancer vs Kafka\n\n| Критерий | LoadBalancer (старая архитектура) | Kafka (новая архитектура) |\n|----------|-----------------------------------|---------------------------|\n| **Сложность** | Высокая (отдельный сервис) | Низкая (только Kafka) |\n| **Идентификация** | HTTP endpoints + IP | UUID в ENV переменной |\n| **Kafka трафик** | ~5 KB на событие | ~120 bytes на событие |\n| **Запись ордеров** | Через LoadBalancer API | Прямо в БД |\n| **Race conditions** | Нужна ручная блокировка | Optimistic locking |\n| **Масштабирование** | Сложное | Простое (добавить consumer) |\n| **Monitoring** | HTTP polling | Kafka heartbeat (кеш) |\n| **Отказоустойчивость** | Single point of failure | Distributed (Kafka) |\n| **Канареечные деплои** | Не реализовано | Готово через Kafka |\n| **Настройка сервера** | API keys, endpoints | Один ENV: BOT_SERVER_ID |\n\n---\n\n## \uD83D\uDCDD TODO: План реализации\n\n### Этап 1: База данных ✅\n- [x] Создать миграцию для версионирования\n- [x] Добавить `version` в Entity классы\n- [x] Обновить Repository методы\n\n### Этап 2: Kafka в RTF\n- [ ] Настроить Kafka Producer\n- [ ] Настроить Kafka Consumer (heartbeat)\n- [ ] Создать события для bot-commands\n- [ ] Реализовать публикацию событий при CREATE/UPDATE/DELETE\n\n### Этап 3: RTF сервисы\n- [ ] Сервис выбора сервера (least loaded)\n- [ ] Consumer для heartbeat\n- [ ] Мониторинг мертвых серверов\n- [ ] Переназначение orphaned ботов\n\n### Этап 4: Bot-server (Python)\n- [ ] Kafka Consumer для команд\n- [ ] Загрузка конфигурации из БД\n- [ ] Запись ордеров в БД\n- [ ] Обновление статистики (с версионированием!)\n- [ ] Heartbeat producer\n\n### Этап 5: Тестирование\n- [ ] Race conditions (параллельные обновления)\n- [ ] Сбой сервера (переназначение ботов)\n- [ ] Kafka downtime (очередь команд)\n- [ ] Нагрузочное тестирование\n\n---\n\n\n",
    "content" : "Based on my analysis of the provided Kafka architecture documentation and the existing project structure, I have created a comprehensive structured specification. Here's a summary of what I've produced:\n\n## Summary of Structured Specification Created:\n\n### 1. **Product Brief** - RTF Platform with Kafka Architecture\n- **Goal**: Event-driven trading bot management system replacing HTTP load balancing with Kafka\n- **Context**: Distributed bot orchestration for trading platform operators\n- **Problem Solved**: Eliminates single points of failure, reduces network traffic, enables automatic failover\n\n### 2. **System Actors** (5 key roles):\n- RTF Backend (Spring Boot on port 8091)\n- Frontend (React on port 3000) \n- Bot Servers (EC2 Python on port 6969)\n- Apache Kafka (port 9092)\n- Database (Aurora PostgreSQL)\n\n### 3. **User Stories** (14 comprehensive stories):\n- Bot Management (create, start, stop, update, close positions)\n- Server Management (health monitoring, automatic reassignment, scaling)\n- Trading Operations (execute trades, update statistics, view performance)\n- System Administration (capacity configuration, manual reassignment, disaster recovery)\n\n### 4. **Non-Functional Requirements**:\n- **Performance**: <100ms command delivery, 1000+ concurrent bots\n- **Reliability**: 99.9% uptime, <2min failover, at-least-once delivery\n- **Security**: API key encryption, SSL/TLS, audit logging\n- **Operational**: Real-time monitoring, zero-downtime deployments\n\n### 5. **Out of Scope** for Version 1.0:\n- Only Grid and DCA bots (no custom strategies)\n- Limited exchange support\n- No social/copy trading\n- No mobile application\n- No automatic EC2 scaling\n- No AI/ML features\n\n### 6. **Open Questions** (categorized):\n- **Technical**: Kafka configuration, database design, Python implementation\n- **Operational**: Deployment strategies, scaling triggers, security practices\n- **Business**: Cost optimization, SLA guarantees, compliance requirements\n- **Implementation**: Versioning strategy, error handling, performance optimization\n\n## Key Technical Insights from Analysis:\n\n### Current Project State:\n- Existing project is a Spring Boot application (Java 25)\n- Currently focused on browser automation with anti-detection features\n- No Kafka dependencies in current `pom.xml`\n- Uses Lombok, Spring Web MVC, REST client\n\n### What Needs to be Added for Kafka Architecture:\n\n1. **Kafka Dependencies** to `pom.xml`:\n   - Spring Kafka\n   - Kafka Clients\n   - Jackson for JSON serialization\n\n2. **Database Schema Changes**:\n   - Version columns for optimistic locking\n   - Bot assignment tables\n   - Server registry tables\n   - Trading order and statistics tables\n\n3. **New Services**:\n   - KafkaProducerService for bot commands\n   - KafkaConsumerService for heartbeats\n   - BotAssignmentService for load balancing\n   - ServerMonitorService for health checks\n\n4. **Bot Server Implementation** (Python):\n   - Kafka consumer for commands\n   - Direct database access for configurations\n   - Heartbeat producer\n   - Trading logic with exchange integration\n\n### Implementation Priority:\n\n**Phase 1: Foundation**\n1. Add Kafka dependencies and configuration\n2. Create database migration scripts\n3. Implement basic Kafka producer/consumer\n\n**Phase 2: Core Services**\n1. Bot management with Kafka events\n2. Server registration and heartbeat\n3. Load balancing algorithm\n\n**Phase 3: Trading Integration**\n1. Bot server Python implementation\n2. Exchange API integration\n3. Order execution and statistics\n\n**Phase 4: Reliability Features**\n1. Automatic failover and reassignment\n2. Monitoring and alerting\n3. Disaster recovery procedures\n\nThe specification provides a clear roadmap for transforming the current browser automation system into a distributed trading bot platform using Kafka event-driven architecture. The key innovation is replacing complex HTTP load balancing with lightweight Kafka messages containing only bot IDs and commands, while maintaining database as the single source of truth.",
    "approvalStatus" : "PENDING_APPROVAL",
    "feedback" : null,
    "createdAt" : "2026-02-23T18:36:43.961052900Z",
    "updatedAt" : "2026-02-23T18:46:20.585377900Z"
  }
}